{
  "version": 3,
  "file": "injector.js",
  "sourceRoot": "/Users/Sergey/Work/EXP/mioc/src",
  "sources": [
    "injector.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import {Class} from \"runtime/reflect/class\";\nimport {Interface} from \"runtime/reflect/class\";\nimport {Property} from \"runtime/reflect/class\";\n\nconst BINDINGS = Symbol('bindings');\n\nexport class Binding<T> {\n\n    private static getInterfaceFor(ref:any):Interface{\n        if(ref instanceof Interface){\n            return ref;\n        }else\n        if(typeof ref == 'string'){\n            var inf = system.classes[ref];\n            if(inf instanceof Interface){\n                return inf;\n            }else{\n                var qNames = Object.keys(system.classes);\n                for(var qName of qNames){\n                    var cls = system.classes[qName];\n                    if(cls && cls.name==ref){\n                        return cls;\n                    }\n                }\n            }\n        }else if(typeof ref == 'function'){\n            return ref.class;\n        }\n    }\n    private static getClassFor(ref:any):Class{\n        var cls = this.getInterfaceFor(ref);\n        if(cls instanceof Class){\n            return cls;\n        } else {\n            return null;\n        }\n    }\n\n    public static bind<T>(\n        injector         : Injector,\n        abstraction      : string | {new():T} | Interface,\n        implementation?  : string | {new():T} | Class,\n        options?         : any\n    ):Binding<T>{\n        var binding = new Binding(injector,abstraction,implementation,options);\n        var bindings = injector[BINDINGS];\n        if(!bindings){\n            bindings = injector[BINDINGS] = Object.create(null);\n        }\n        if(!bindings[binding.id]){\n            bindings[binding.id] = binding;\n        }else{\n            throw new Error('already bounded');\n        }\n        return binding;\n    }\n    public static find(injector:Injector,abstraction:any):Binding<any>{\n        var ref = Binding.getInterfaceFor(abstraction).id;\n        var binding = injector[BINDINGS][ref];\n        if(!binding){\n            var cls = system.classes[ref];\n            if(cls instanceof Class){\n                binding = injector[BINDINGS][ref] = Binding.bind(injector,ref,cls);\n            }else{\n                throw new Error(`Invalid abstraction ${abstraction}`)\n            }\n        }\n        return binding;\n    }\n\n    public id:string;\n    public injector:Injector;\n    public abstraction:Interface;\n    public implementation:Class;\n    public options:any;\n    public instance:T;\n\n    constructor(\n        injector         : Injector,\n        abstraction      : string | {new():T} | Interface,\n        implementation?  : string | {new():T} | Class,\n        options?         : any\n    ){\n        this.injector = injector;\n        this.abstraction = Binding.getInterfaceFor(abstraction);\n        this.implementation = Binding.getClassFor(implementation);\n        this.options = this.implementation.metadata.injectable || {};\n        this.id = this.abstraction.id;\n        for(var o in options){\n            this.options[o] = options[o];\n        }\n    }\n\n    public get(args:any[]):T{\n        if(this.options.singleton){\n            if(!this.instance){\n                this.instance = this.instantiate(args);\n            }\n            return this.instance;\n        }else{\n            return this.instantiate(args);\n        }\n    }\n\n    public instantiate(args:any[]):T{\n        var Class = this.implementation;\n        var Constructor = Class.value;\n        var instance = Object.create(null);\n        Object.keys(Class.members).forEach((m)=>{\n            var member = Class.members[m];\n            if(member instanceof Property && member.metadata.injected){\n                instance[member.name] = this.injector.get(member.type.reference);\n            }\n        });\n        Object.setPrototypeOf(instance,Constructor.prototype);\n        Constructor.apply(instance,args);\n        return <T>instance;\n    }\n}\nexport class Injector {\n    private [BINDINGS]:{[k:string]:Binding<any>};\n\n    bind<T>(\n        abstraction      : string | {new():T} | Interface,\n        implementation?  : string | {new():T} | Class,\n        options?         : any\n    ):Binding<T>{\n        return Binding.bind(this,abstraction,implementation,options);\n    }\n\n    get<T>(ref:string|{new():T}|Interface,...args:any[]):T{\n        return Binding.find(this,ref).get(args);\n    }\n}\n\nexport default Injector;"
  ]
}